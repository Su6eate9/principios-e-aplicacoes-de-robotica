<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Transformação de Pontos - Local e Global</title>
    <style>
      body {
        font-family: "Arial", sans-serif;
        margin: 0;
        padding: 10px;
        background-color: #0a0a0a;
        min-height: 100vh;
        color: #e0e0e0;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        background-color: #1a1a1a;
        border-radius: 8px;
        padding: 15px;
        border: 1px solid #333;
      }

      .title {
        text-align: center;
        font-size: 1.4em;
        margin-bottom: 20px;
        color: #ffffff;
        font-weight: 300;
        line-height: 1.3;
      }

      .controls-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 15px;
        margin-bottom: 15px;
      }

      .control-panel {
        background-color: #2a2a2a;
        padding: 15px;
        border-radius: 6px;
        border: 1px solid #404040;
      }

      .control-panel h3 {
        margin-top: 0;
        margin-bottom: 15px;
        text-align: center;
        color: #ffffff;
        font-weight: 400;
        font-size: 1em;
      }

      .control-group {
        margin-bottom: 12px;
      }

      label {
        display: block;
        margin-bottom: 6px;
        font-weight: 400;
        color: #b0b0b0;
        font-size: 13px;
      }

      input[type="range"] {
        width: 100%;
        margin-bottom: 5px;
        -webkit-appearance: none;
        height: 6px;
        background: #404040;
        border-radius: 3px;
        outline: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 22px;
        height: 22px;
        background: #ffffff;
        border-radius: 50%;
        cursor: pointer;
      }

      input[type="range"]::-moz-range-thumb {
        width: 22px;
        height: 22px;
        background: #ffffff;
        border-radius: 50%;
        cursor: pointer;
        border: none;
      }

      .value-display {
        text-align: center;
        font-weight: 500;
        color: #ffffff;
        font-size: 13px;
      }

      .canvas-container {
        display: flex;
        justify-content: center;
        margin-top: 15px;
        overflow-x: auto;
        padding: 0 5px;
      }

      canvas {
        border: 1px solid #404040;
        border-radius: 6px;
        background: #ffffff;
        max-width: 100%;
        height: auto;
      }

      .button-group {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        justify-content: center;
        margin-top: 15px;
      }

      button {
        padding: 12px 8px;
        border: 1px solid #555;
        border-radius: 4px;
        background-color: #333;
        color: #e0e0e0;
        font-weight: 400;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 13px;
        text-align: center;
        min-height: 44px;
      }

      button:hover {
        background-color: #444;
        border-color: #666;
      }

      .info-panel {
        margin-top: 15px;
        padding: 12px;
        background-color: #2a2a2a;
        border-radius: 6px;
        border: 1px solid #404040;
        text-align: left;
        font-size: 12px;
        line-height: 1.4;
      }

      .info-panel p {
        margin: 6px 0;
        color: #b0b0b0;
      }

      .local-rotation {
        border-left: 3px solid #4caf50;
      }

      .global-rotation {
        border-left: 3px solid #2196f3;
      }

      .local-translation {
        border-left: 3px solid #ff9800;
      }

      .global-translation {
        border-left: 3px solid #9c27b0;
      }

      input[type="checkbox"] {
        margin-right: 8px;
      }

      /* Tablet Styles */
      @media (min-width: 768px) {
        body {
          padding: 20px;
        }

        .container {
          padding: 25px;
        }

        .title {
          font-size: 1.8em;
          margin-bottom: 25px;
        }

        .controls-grid {
          grid-template-columns: repeat(2, 1fr);
          gap: 18px;
          margin-bottom: 18px;
        }

        .control-panel {
          padding: 18px;
        }

        .control-panel h3 {
          font-size: 1.05em;
        }

        .button-group {
          grid-template-columns: repeat(3, 1fr);
          gap: 10px;
          margin-top: 18px;
        }

        button {
          font-size: 14px;
          padding: 10px 16px;
        }

        label {
          font-size: 14px;
          margin-bottom: 7px;
        }

        .info-panel {
          font-size: 13px;
          padding: 14px;
          margin-top: 18px;
        }
      }

      /* Desktop Styles */
      @media (min-width: 1024px) {
        body {
          padding: 25px;
        }

        .container {
          padding: 30px;
        }

        .title {
          font-size: 2.2em;
          margin-bottom: 30px;
        }

        .controls-grid {
          grid-template-columns: repeat(4, 1fr);
          gap: 20px;
          margin-bottom: 20px;
        }

        .control-panel {
          padding: 20px;
        }

        .control-panel h3 {
          font-size: 1.1em;
        }

        .control-group {
          margin-bottom: 15px;
        }

        .button-group {
          display: flex;
          gap: 10px;
          justify-content: center;
          flex-wrap: wrap;
          margin-top: 20px;
        }

        button {
          padding: 10px 20px;
          font-size: 14px;
          min-height: auto;
        }

        input[type="range"]::-webkit-slider-thumb {
          width: 18px;
          height: 18px;
        }

        input[type="range"]::-moz-range-thumb {
          width: 18px;
          height: 18px;
        }

        label {
          font-size: 14px;
          margin-bottom: 8px;
        }

        .canvas-container {
          margin-top: 20px;
          padding: 0;
        }

        .info-panel {
          font-size: 14px;
          padding: 15px;
          margin-top: 20px;
        }

        .info-panel p {
          margin: 8px 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 class="title">Transformação de Pontos - Local e Global</h1>

      <div class="controls-grid">
        <div class="control-panel local-rotation">
          <h3>Rotação Local</h3>
          <div class="control-group">
            <label for="localRotation">Ângulo (graus):</label>
            <input
              type="range"
              id="localRotation"
              min="0"
              max="360"
              value="0"
            />
            <div class="value-display" id="localRotationValue">0°</div>
          </div>
          <p
            style="font-size: 12px; text-align: center; margin: 0; color: #888"
          >
            Vetores rotacionam em torno dos próprios pontos
          </p>
        </div>

        <div class="control-panel global-rotation">
          <h3>Rotação Global</h3>
          <div class="control-group">
            <label for="globalRotation">Ângulo (graus):</label>
            <input
              type="range"
              id="globalRotation"
              min="0"
              max="360"
              value="0"
            />
            <div class="value-display" id="globalRotationValue">0°</div>
          </div>

          <div class="control-group">
            <label for="centerX">Centro X:</label>
            <input
              type="range"
              id="centerX"
              min="0"
              max="10"
              value="3"
              step="0.1"
            />
            <div class="value-display" id="centerXValue">3.0</div>
          </div>

          <div class="control-group">
            <label for="centerY">Centro Y:</label>
            <input
              type="range"
              id="centerY"
              min="0"
              max="5"
              value="2"
              step="0.1"
            />
            <div class="value-display" id="centerYValue">2.0</div>
          </div>
        </div>

        <div class="control-panel local-translation">
          <h3>Translação Local</h3>
          <div class="control-group">
            <label for="localTranslateX">Deslocamento X:</label>
            <input
              type="range"
              id="localTranslateX"
              min="-2"
              max="2"
              value="0"
              step="0.1"
            />
            <div class="value-display" id="localTranslateXValue">0.0</div>
          </div>

          <div class="control-group">
            <label for="localTranslateY">Deslocamento Y:</label>
            <input
              type="range"
              id="localTranslateY"
              min="-2"
              max="2"
              value="0"
              step="0.1"
            />
            <div class="value-display" id="localTranslateYValue">0.0</div>
          </div>
          <p
            style="font-size: 12px; text-align: center; margin: 0; color: #888"
          >
            Cada ponto se move independentemente
          </p>
        </div>

        <div class="control-panel global-translation">
          <h3>Translação Global</h3>
          <div class="control-group">
            <label for="globalTranslateX">Deslocamento X:</label>
            <input
              type="range"
              id="globalTranslateX"
              min="-5"
              max="5"
              value="0"
              step="0.1"
            />
            <div class="value-display" id="globalTranslateXValue">0.0</div>
          </div>

          <div class="control-group">
            <label for="globalTranslateY">Deslocamento Y:</label>
            <input
              type="range"
              id="globalTranslateY"
              min="-3"
              max="3"
              value="0"
              step="0.1"
            />
            <div class="value-display" id="globalTranslateYValue">0.0</div>
          </div>

          <div class="control-group">
            <label>
              <input type="checkbox" id="showVectors" checked /> Mostrar Vetores
            </label>
          </div>
        </div>
      </div>

      <div class="button-group">
        <button onclick="resetTransformations()">Reset</button>
        <button onclick="animateLocalRotation()">Animar Rotação Local</button>
        <button onclick="animateGlobalRotation()">Animar Rotação Global</button>
        <button onclick="animateTranslation()">Animar Translação</button>
        <button onclick="toggleAnimation()">Pausar/Play</button>
      </div>

      <div class="canvas-container">
        <canvas id="canvas" width="350" height="280"></canvas>
      </div>

      <div class="info-panel">
        <p>
          <strong>Rotação Local:</strong> Vetores X e Y de cada ponto rotacionam
          em torno do próprio ponto.
        </p>
        <p>
          <strong>Rotação Global:</strong> Todos os pontos rotacionam em torno
          de um centro comum.
        </p>
        <p>
          <strong>Translação Local:</strong> Cada ponto se move
          independentemente na mesma direção.
        </p>
        <p>
          <strong>Translação Global:</strong> Todo o sistema se move junto
          mantendo as posições relativas.
        </p>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      const originalPoints = {
        P: { x: 3, y: 2, color: "#000000", label: "P" },
        point1: { x: 1, y: 2, color: "#9c27b0", label: "{1}" },
        point2: { x: 2, y: 1, color: "#f44336", label: "{2}" },
        point3: { x: 2.5, y: 3.8, color: "#4caf50", label: "{3}" },
        point4: { x: 3, y: 3, color: "#2196f3", label: "{4}" },
      };

      let transformedPoints = {};
      let animationId = null;
      let animationAngle = 0;
      let isAnimating = false;
      let animationType = "none";

      // Escala e offset para o canvas - responsivo
      let scale = 35;
      let offsetX = 40;
      let offsetY = 260;

      function adjustCanvasForScreen() {
        const screenWidth = window.innerWidth;

        if (screenWidth >= 1024) {
          canvas.width = 900;
          canvas.height = 700;
          scale = 80;
          offsetX = 100;
          offsetY = 650;
        } else if (screenWidth >= 768) {
          canvas.width = 600;
          canvas.height = 480;
          scale = 55;
          offsetX = 70;
          offsetY = 450;
        } else {
          canvas.width = Math.min(350, screenWidth - 40);
          canvas.height = 280;
          scale = 30;
          offsetX = 30;
          offsetY = 260;
        }

        if (transformedPoints.P) {
          draw();
        }
      }

      function canvasX(x) {
        return x * scale + offsetX;
      }

      function canvasY(y) {
        return offsetY - y * scale;
      }

      function rotatePoint(point, centerX, centerY, angle) {
        const rad = (angle * Math.PI) / 180;
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);

        const dx = point.x - centerX;
        const dy = point.y - centerY;

        return {
          x: centerX + dx * cos - dy * sin,
          y: centerY + dx * sin + dy * cos,
          color: point.color,
          label: point.label,
        };
      }

      function translatePoint(point, dx, dy) {
        return {
          x: point.x + dx,
          y: point.y + dy,
          color: point.color,
          label: point.label,
        };
      }

      function drawGrid() {
        ctx.strokeStyle = "#e0e0e0";
        ctx.lineWidth = 1;

        for (let i = 0; i <= 12; i++) {
          ctx.beginPath();
          ctx.moveTo(canvasX(i), canvasY(0));
          ctx.lineTo(canvasX(i), canvasY(8));
          ctx.stroke();
        }

        for (let i = 0; i <= 8; i++) {
          ctx.beginPath();
          ctx.moveTo(canvasX(0), canvasY(i));
          ctx.lineTo(canvasX(12), canvasY(i));
          ctx.stroke();
        }

        ctx.strokeStyle = "#666";
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(canvasX(0), canvasY(0));
        ctx.lineTo(canvasX(12), canvasY(0));
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(canvasX(0), canvasY(0));
        ctx.lineTo(canvasX(0), canvasY(8));
        ctx.stroke();

        ctx.fillStyle = "#333";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";

        for (let i = 1; i <= 12; i++) {
          ctx.fillText(i.toString(), canvasX(i), canvasY(0) + 15);
        }

        ctx.textAlign = "right";
        for (let i = 1; i <= 8; i++) {
          ctx.fillText(i.toString(), canvasX(0) - 10, canvasY(i) + 4);
        }
      }

      function drawPoint(point, isOriginal = false, isFixed = false) {
        const x = canvasX(point.x);
        const y = canvasY(point.y);

        const pointSize = scale < 40 ? 6 : scale < 60 ? 7 : 8;
        const originalSize = scale < 40 ? 3 : 4;
        const squareSize = scale < 40 ? 5 : 6;
        const fontSize = scale < 40 ? "12px" : scale < 60 ? "14px" : "16px";
        const labelOffset = scale < 40 ? 8 : scale < 60 ? 10 : 12;

        ctx.fillStyle = point.color;
        ctx.beginPath();

        if (isFixed) {
          // Ponto P fixo - formato quadrado
          ctx.fillRect(
            x - squareSize,
            y - squareSize,
            squareSize * 2,
            squareSize * 2
          );
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = scale < 40 ? 2 : 3;
          ctx.strokeRect(
            x - squareSize,
            y - squareSize,
            squareSize * 2,
            squareSize * 2
          );
        } else {
          ctx.arc(x, y, isOriginal ? originalSize : pointSize, 0, 2 * Math.PI);
          ctx.fill();

          if (!isOriginal) {
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        }

        ctx.fillStyle = point.color;
        ctx.font = `bold ${fontSize} Arial`;
        ctx.textAlign = "left";
        ctx.fillText(point.label, x + labelOffset, y - labelOffset);
      }

      function drawVector(from, to, color = "#00ff00", lineWidth = 3) {
        const x1 = canvasX(from.x);
        const y1 = canvasY(from.y);
        const x2 = canvasX(to.x);
        const y2 = canvasY(to.y);

        const adjustedLineWidth = scale < 40 ? 2 : scale < 60 ? 3 : 4;
        const headLength = scale < 40 ? 6 : scale < 60 ? 8 : 10;

        ctx.strokeStyle = color;
        ctx.lineWidth = adjustedLineWidth;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        const angle = Math.atan2(y2 - y1, x2 - x1);

        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(
          x2 - headLength * Math.cos(angle - Math.PI / 6),
          y2 - headLength * Math.sin(angle - Math.PI / 6)
        );
        ctx.moveTo(x2, y2);
        ctx.lineTo(
          x2 - headLength * Math.cos(angle + Math.PI / 6),
          y2 - headLength * Math.sin(angle + Math.PI / 6)
        );
        ctx.stroke();
      }

      function drawComponentVectors(
        pointTransformed,
        pointColor,
        pointLabel,
        localRotationAngle
      ) {
        const origin = pointTransformed;
        const vectorLength = scale < 40 ? 1.2 : 1.5;

        const localRad = (localRotationAngle * Math.PI) / 180;
        const cos = Math.cos(localRad);
        const sin = Math.sin(localRad);

        const endPointX = {
          x: origin.x + vectorLength * cos,
          y: origin.y + vectorLength * sin,
        };

        const endPointY = {
          x: origin.x - vectorLength * sin,
          y: origin.y + vectorLength * cos,
        };

        drawVector(origin, endPointX, pointColor, 4);
        drawVector(origin, endPointY, pointColor, 4);

        const fontSize = scale < 40 ? "10px" : scale < 60 ? "12px" : "14px";
        const labelDistance = scale < 40 ? 10 : 15;

        ctx.fillStyle = pointColor;
        ctx.font = `bold ${fontSize} Arial`;
        ctx.textAlign = "center";

        ctx.fillText(
          `X${pointLabel}`,
          canvasX(endPointX.x) + labelDistance * Math.cos(localRad),
          canvasY(endPointX.y) - labelDistance * Math.sin(localRad)
        );

        ctx.fillText(
          `Y${pointLabel}`,
          canvasX(endPointY.x) - labelDistance * Math.sin(localRad),
          canvasY(endPointY.y) - labelDistance * Math.cos(localRad)
        );

        const cornerSize = scale < 40 ? 10 : scale < 60 ? 12 : 15;

        ctx.lineWidth = scale < 40 ? 1 : 2;
        ctx.beginPath();

        const corner1X = origin.x + cornerSize * cos;
        const corner1Y = origin.y + cornerSize * sin;
        const corner2X = corner1X - cornerSize * sin;
        const corner2Y = corner1Y + cornerSize * cos;
        const corner3X = origin.x - cornerSize * sin;
        const corner3Y = origin.y + cornerSize * cos;

        ctx.moveTo(canvasX(corner1X), canvasY(corner1Y));
        ctx.lineTo(canvasX(corner2X), canvasY(corner2Y));
        ctx.lineTo(canvasX(corner3X), canvasY(corner3Y));
        ctx.stroke();
      }

      function updateTransformations() {
        const localRotation = parseFloat(
          document.getElementById("localRotation").value
        );
        const globalRotation = parseFloat(
          document.getElementById("globalRotation").value
        );
        const centerX = parseFloat(document.getElementById("centerX").value);
        const centerY = parseFloat(document.getElementById("centerY").value);
        const localTranslateX = parseFloat(
          document.getElementById("localTranslateX").value
        );
        const localTranslateY = parseFloat(
          document.getElementById("localTranslateY").value
        );
        const globalTranslateX = parseFloat(
          document.getElementById("globalTranslateX").value
        );
        const globalTranslateY = parseFloat(
          document.getElementById("globalTranslateY").value
        );

        transformedPoints = {};

        for (const [key, point] of Object.entries(originalPoints)) {
          if (key === "P") {
            let transformed = translatePoint(
              point,
              globalTranslateX,
              globalTranslateY
            );
            transformedPoints[key] = transformed;
          } else {
            let transformed = translatePoint(
              point,
              localTranslateX,
              localTranslateY
            );
            transformed = rotatePoint(
              transformed,
              centerX,
              centerY,
              globalRotation
            );
            transformed = translatePoint(
              transformed,
              globalTranslateX,
              globalTranslateY
            );
            transformedPoints[key] = transformed;
          }
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawGrid();

        ctx.globalAlpha = 0.3;
        for (const [key, point] of Object.entries(originalPoints)) {
          drawPoint(point, true, key === "P");
        }
        ctx.globalAlpha = 1;

        for (const [key, point] of Object.entries(transformedPoints)) {
          drawPoint(point, false, key === "P");
        }

        if (document.getElementById("showVectors").checked) {
          const localRotationAngle = parseFloat(
            document.getElementById("localRotation").value
          );

          for (const [key, originalPoint] of Object.entries(originalPoints)) {
            if (key !== "P") {
              const transformedPoint = transformedPoints[key];
              const pointNumber = key.replace("point", "");

              drawComponentVectors(
                transformedPoint,
                transformedPoint.color,
                pointNumber,
                localRotationAngle
              );
            }
          }
        }
      }

      function updateValueDisplays() {
        document.getElementById("localRotationValue").textContent =
          document.getElementById("localRotation").value + "°";
        document.getElementById("globalRotationValue").textContent =
          document.getElementById("globalRotation").value + "°";
        document.getElementById("centerXValue").textContent = parseFloat(
          document.getElementById("centerX").value
        ).toFixed(1);
        document.getElementById("centerYValue").textContent = parseFloat(
          document.getElementById("centerY").value
        ).toFixed(1);
        document.getElementById("localTranslateXValue").textContent =
          parseFloat(document.getElementById("localTranslateX").value).toFixed(
            1
          );
        document.getElementById("localTranslateYValue").textContent =
          parseFloat(document.getElementById("localTranslateY").value).toFixed(
            1
          );
        document.getElementById("globalTranslateXValue").textContent =
          parseFloat(document.getElementById("globalTranslateX").value).toFixed(
            1
          );
        document.getElementById("globalTranslateYValue").textContent =
          parseFloat(document.getElementById("globalTranslateY").value).toFixed(
            1
          );
      }

      function resetTransformations() {
        document.getElementById("localRotation").value = 0;
        document.getElementById("globalRotation").value = 0;
        document.getElementById("centerX").value = 3;
        document.getElementById("centerY").value = 2;
        document.getElementById("localTranslateX").value = 0;
        document.getElementById("localTranslateY").value = 0;
        document.getElementById("globalTranslateX").value = 0;
        document.getElementById("globalTranslateY").value = 0;
        updateValueDisplays();
        updateTransformations();
        draw();
        isAnimating = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
      }

      function animateLocalRotation() {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }

        isAnimating = true;
        animationType = "local";
        animationAngle = 0;

        function animate() {
          animationAngle += 3;
          document.getElementById("localRotation").value = animationAngle % 360;
          updateValueDisplays();
          updateTransformations();
          draw();

          if (isAnimating && animationType === "local") {
            animationId = requestAnimationFrame(animate);
          }
        }

        animate();
      }

      function animateGlobalRotation() {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }

        isAnimating = true;
        animationType = "global";
        animationAngle = 0;

        function animate() {
          animationAngle += 2;
          document.getElementById("globalRotation").value =
            animationAngle % 360;
          updateValueDisplays();
          updateTransformations();
          draw();

          if (isAnimating && animationType === "global") {
            animationId = requestAnimationFrame(animate);
          }
        }

        animate();
      }

      function animateTranslation() {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }

        isAnimating = true;
        animationType = "translation";
        animationAngle = 0;

        function animate() {
          animationAngle += 0.1;
          const translateValue = Math.sin(animationAngle) * 2;
          document.getElementById("globalTranslateX").value = translateValue;
          document.getElementById("globalTranslateY").value =
            translateValue * 0.5;
          updateValueDisplays();
          updateTransformations();
          draw();

          if (isAnimating && animationType === "translation") {
            animationId = requestAnimationFrame(animate);
          }
        }

        animate();
      }

      function toggleAnimation() {
        isAnimating = !isAnimating;
        if (!isAnimating && animationId) {
          cancelAnimationFrame(animationId);
          animationType = "none";
        } else if (isAnimating) {
          switch (animationType) {
            case "local":
              animateLocalRotation();
              break;
            case "global":
              animateGlobalRotation();
              break;
            case "translation":
              animateTranslation();
              break;
          }
        }
      }

      const controls = [
        "localRotation",
        "globalRotation",
        "centerX",
        "centerY",
        "localTranslateX",
        "localTranslateY",
        "globalTranslateX",
        "globalTranslateY",
      ];

      controls.forEach((controlId) => {
        document.getElementById(controlId).addEventListener("input", () => {
          updateValueDisplays();
          updateTransformations();
          draw();
        });
      });

      document.getElementById("showVectors").addEventListener("change", () => {
        draw();
      });

      window.addEventListener("resize", () => {
        adjustCanvasForScreen();
      });

      adjustCanvasForScreen();
      updateValueDisplays();
      updateTransformations();
      draw();
    </script>
  </body>
</html>
